{"version":3,"sources":["../../src/utils/websocket-manager.ts"],"names":["hashPaths","paths","map","path","update","digest","WebsocketManager","activePaths","Set","clients","errors","Map","pageResults","staticQueryResults","init","server","websocket","pingTimeout","updateServerActivePaths","serverActivePaths","client","activePath","add","on","socket","clientInfo","setActivePath","newActivePath","fallbackTo404","activePagePath","page","store","getState","handshake","headers","referer","url","parse","forEach","message","errorID","send","type","payload","id","delete","_path","process","env","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","emitter","emitDirtyQueriesIds","getSocket","emitStaticQueryData","data","set","size","telemetry","trackCli","siteMeasurements","clientsCount","Array","from","debounce","emitPageData","emitError","dirtyQueries","queries","dirtyQueriesListToEmitViaWebsocket","length","dispatch","websocketManager"],"mappings":"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","sourcesContent":["/* eslint-disable no-invalid-this */\n\nimport { store, emitter } from \"../redux\"\nimport { clearDirtyQueriesListToEmitViaWebsocket } from \"../redux/actions/internal\"\nimport { Server as HTTPSServer } from \"https\"\nimport { Server as HTTPServer } from \"http\"\nimport { IPageDataWithQueryResult } from \"../utils/page-data\"\nimport telemetry from \"gatsby-telemetry\"\nimport url from \"url\"\nimport { createHash } from \"crypto\"\nimport { findPageByPath } from \"./find-page-by-path\"\nimport socketIO from \"socket.io\"\n\nexport interface IPageQueryResult {\n  id: string\n  result?: IPageDataWithQueryResult\n}\n\nexport interface IStaticQueryResult {\n  id: string\n  result: unknown // TODO: Improve this once we understand what the type is\n}\n\ntype PageResultsMap = Map<string, IPageQueryResult>\ntype QueryResultsMap = Map<string, IStaticQueryResult>\n\nfunction hashPaths(paths: Array<string>): Array<string> {\n  return paths.map(path => createHash(`sha256`).update(path).digest(`hex`))\n}\n\ninterface IClientInfo {\n  activePath: string | null\n  socket: socketIO.Socket\n}\n\nexport class WebsocketManager {\n  activePaths: Set<string> = new Set()\n  clients: Set<IClientInfo> = new Set()\n  errors: Map<string, string> = new Map()\n  pageResults: PageResultsMap = new Map()\n  staticQueryResults: QueryResultsMap = new Map()\n  websocket: socketIO.Server | undefined\n\n  init = ({\n    server,\n  }: {\n    server: HTTPSServer | HTTPServer\n  }): socketIO.Server => {\n    this.websocket = socketIO(server, {\n      // we see ping-pong timeouts on gatsby-cloud when socket.io is running for a while\n      // increasing it should help\n      // @see https://github.com/socketio/socket.io/issues/3259#issuecomment-448058937\n      pingTimeout: 30000,\n    })\n\n    const updateServerActivePaths = (): void => {\n      const serverActivePaths = new Set<string>()\n      for (const client of this.clients) {\n        if (client.activePath) {\n          serverActivePaths.add(client.activePath)\n        }\n      }\n      this.activePaths = serverActivePaths\n    }\n\n    this.websocket.on(`connection`, socket => {\n      const clientInfo: IClientInfo = {\n        activePath: null,\n        socket,\n      }\n      this.clients.add(clientInfo)\n\n      const setActivePath = (\n        newActivePath: string | null,\n        fallbackTo404: boolean = false\n      ): void => {\n        let activePagePath: string | null = null\n        if (newActivePath) {\n          const page = findPageByPath(\n            store.getState(),\n            newActivePath,\n            fallbackTo404\n          )\n          if (page) {\n            activePagePath = page.path\n          }\n        }\n        clientInfo.activePath = activePagePath\n        updateServerActivePaths()\n      }\n\n      if (socket?.handshake?.headers?.referer) {\n        const path = url.parse(socket.handshake.headers.referer).path\n        setActivePath(path, true)\n      }\n\n      this.errors.forEach((message, errorID) => {\n        socket.send({\n          type: `overlayError`,\n          payload: {\n            id: errorID,\n            message,\n          },\n        })\n      })\n\n      socket.on(`registerPath`, (path: string): void => {\n        setActivePath(path, true)\n      })\n\n      socket.on(`disconnect`, (): void => {\n        setActivePath(null)\n        this.clients.delete(clientInfo)\n      })\n\n      socket.on(`unregisterPath`, (_path: string): void => {\n        setActivePath(null)\n      })\n    })\n\n    if (process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {\n      emitter.on(`CREATE_PAGE`, this.emitDirtyQueriesIds)\n      emitter.on(`CREATE_NODE`, this.emitDirtyQueriesIds)\n      emitter.on(`DELETE_NODE`, this.emitDirtyQueriesIds)\n      emitter.on(`QUERY_EXTRACTED`, this.emitDirtyQueriesIds)\n    }\n\n    return this.websocket\n  }\n\n  getSocket = (): socketIO.Server | undefined => this.websocket\n\n  emitStaticQueryData = (data: IStaticQueryResult): void => {\n    this.staticQueryResults.set(data.id, data)\n\n    if (this.websocket) {\n      this.websocket.send({ type: `staticQueryResult`, payload: data })\n\n      if (this.clients.size > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount: this.clients.size,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitPageData = (data: IPageQueryResult): void => {\n    this.pageResults.set(data.id, data)\n\n    if (this.websocket) {\n      this.websocket.send({ type: `pageQueryResult`, payload: data })\n\n      if (this.clients.size > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount: this.clients.size,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitError = (id: string, message?: string): void => {\n    if (message) {\n      this.errors.set(id, message)\n    } else {\n      this.errors.delete(id)\n    }\n\n    if (this.websocket) {\n      this.websocket.send({\n        type: `overlayError`,\n        payload: { id, message },\n      })\n    }\n  }\n\n  emitDirtyQueriesIds = (): void => {\n    const dirtyQueries = store.getState().queries\n      .dirtyQueriesListToEmitViaWebsocket\n\n    if (dirtyQueries.length > 0) {\n      if (this.websocket) {\n        this.websocket.send({\n          type: `dirtyQueries`,\n          payload: { dirtyQueries },\n        })\n\n        store.dispatch(clearDirtyQueriesListToEmitViaWebsocket())\n      }\n    }\n  }\n}\n\nexport const websocketManager: WebsocketManager = new WebsocketManager()\n"],"file":"websocket-manager.js"}