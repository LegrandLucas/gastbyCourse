"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.websocketManager = exports.WebsocketManager = void 0;

var _redux = require("../redux");

var _internal = require("../redux/actions/internal");

var _gatsbyTelemetry = _interopRequireDefault(require("gatsby-telemetry"));

var _url = _interopRequireDefault(require("url"));

var _crypto = require("crypto");

var _findPageByPath = require("./find-page-by-path");

var _socket = _interopRequireDefault(require("socket.io"));

/* eslint-disable no-invalid-this */
function hashPaths(paths) {
  return paths.map(path => (0, _crypto.createHash)(`sha256`).update(path).digest(`hex`));
}

class WebsocketManager {
  constructor() {
    this.activePaths = new Set();
    this.clients = new Set();
    this.errors = new Map();
    this.pageResults = new Map();
    this.staticQueryResults = new Map();

    this.init = ({
      server
    }) => {
      this.websocket = (0, _socket.default)(server, {
        // we see ping-pong timeouts on gatsby-cloud when socket.io is running for a while
        // increasing it should help
        // @see https://github.com/socketio/socket.io/issues/3259#issuecomment-448058937
        pingTimeout: 30000
      });

      const updateServerActivePaths = () => {
        const serverActivePaths = new Set();

        for (const client of this.clients) {
          if (client.activePath) {
            serverActivePaths.add(client.activePath);
          }
        }

        this.activePaths = serverActivePaths;
      };

      this.websocket.on(`connection`, socket => {
        var _socket$handshake, _socket$handshake$hea;

        const clientInfo = {
          activePath: null,
          socket
        };
        this.clients.add(clientInfo);

        const setActivePath = (newActivePath, fallbackTo404 = false) => {
          let activePagePath = null;

          if (newActivePath) {
            const page = (0, _findPageByPath.findPageByPath)(_redux.store.getState(), newActivePath, fallbackTo404);

            if (page) {
              activePagePath = page.path;
            }
          }

          clientInfo.activePath = activePagePath;
          updateServerActivePaths();
        };

        if (socket === null || socket === void 0 ? void 0 : (_socket$handshake = socket.handshake) === null || _socket$handshake === void 0 ? void 0 : (_socket$handshake$hea = _socket$handshake.headers) === null || _socket$handshake$hea === void 0 ? void 0 : _socket$handshake$hea.referer) {
          const path = _url.default.parse(socket.handshake.headers.referer).path;

          setActivePath(path, true);
        }

        this.errors.forEach((message, errorID) => {
          socket.send({
            type: `overlayError`,
            payload: {
              id: errorID,
              message
            }
          });
        });
        socket.on(`registerPath`, path => {
          setActivePath(path, true);
        });
        socket.on(`disconnect`, () => {
          setActivePath(null);
          this.clients.delete(clientInfo);
        });
        socket.on(`unregisterPath`, _path => {
          setActivePath(null);
        });
      });

      if (process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {
        _redux.emitter.on(`CREATE_PAGE`, this.emitDirtyQueriesIds);

        _redux.emitter.on(`CREATE_NODE`, this.emitDirtyQueriesIds);

        _redux.emitter.on(`DELETE_NODE`, this.emitDirtyQueriesIds);

        _redux.emitter.on(`QUERY_EXTRACTED`, this.emitDirtyQueriesIds);
      }

      return this.websocket;
    };

    this.getSocket = () => this.websocket;

    this.emitStaticQueryData = data => {
      this.staticQueryResults.set(data.id, data);

      if (this.websocket) {
        this.websocket.send({
          type: `staticQueryResult`,
          payload: data
        });

        if (this.clients.size > 0) {
          _gatsbyTelemetry.default.trackCli(`WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`, {
            siteMeasurements: {
              clientsCount: this.clients.size,
              paths: hashPaths(Array.from(this.activePaths))
            }
          }, {
            debounce: true
          });
        }
      }
    };

    this.emitPageData = data => {
      this.pageResults.set(data.id, data);

      if (this.websocket) {
        this.websocket.send({
          type: `pageQueryResult`,
          payload: data
        });

        if (this.clients.size > 0) {
          _gatsbyTelemetry.default.trackCli(`WEBSOCKET_EMIT_PAGE_DATA_UPDATE`, {
            siteMeasurements: {
              clientsCount: this.clients.size,
              paths: hashPaths(Array.from(this.activePaths))
            }
          }, {
            debounce: true
          });
        }
      }
    };

    this.emitError = (id, message) => {
      if (message) {
        this.errors.set(id, message);
      } else {
        this.errors.delete(id);
      }

      if (this.websocket) {
        this.websocket.send({
          type: `overlayError`,
          payload: {
            id,
            message
          }
        });
      }
    };

    this.emitDirtyQueriesIds = () => {
      const dirtyQueries = _redux.store.getState().queries.dirtyQueriesListToEmitViaWebsocket;

      if (dirtyQueries.length > 0) {
        if (this.websocket) {
          this.websocket.send({
            type: `dirtyQueries`,
            payload: {
              dirtyQueries
            }
          });

          _redux.store.dispatch((0, _internal.clearDirtyQueriesListToEmitViaWebsocket)());
        }
      }
    };
  }

}

exports.WebsocketManager = WebsocketManager;
const websocketManager = new WebsocketManager();
exports.websocketManager = websocketManager;
//# sourceMappingURL=websocket-manager.js.map