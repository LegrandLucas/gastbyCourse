{"version":3,"sources":["../../../src/utils/dev-ssr/render-dev-html.ts"],"names":["startWorker","newWorker","JestWorker","require","resolve","exposedMethods","numWorkers","forkOptions","silent","warmup","worker","initDevWorkerPool","changeCount","restartWorker","htmlComponentRendererPath","oldWorker","end","deleteModuleCache","renderDevHTML","path","page","store","directory","Promise","reject","pageObj","getState","isClientOnlyPage","matchPath","htmlString","renderHTML","componentPath","component","error"],"mappings":";;;;;;;AAAA;;AAGA;;AACA;;AACA;;AAEA,MAAMA,WAAW,GAAG,MAAW;AAC7B,QAAMC,SAAS,GAAG,IAAIC,mBAAJ,CAAeC,OAAO,CAACC,OAAR,CAAiB,yBAAjB,CAAf,EAA2D;AAC3EC,IAAAA,cAAc,EAAE,CAAE,YAAF,EAAgB,mBAAhB,EAAqC,QAArC,CAD2D;AAE3EC,IAAAA,UAAU,EAAE,CAF+D;AAG3EC,IAAAA,WAAW,EAAE;AAAEC,MAAAA,MAAM,EAAE;AAAV;AAH8D,GAA3D,CAAlB,CAD6B,CAO7B;AACA;AACA;;AACAP,EAAAA,SAAS,CAACQ,MAAV;AAEA,SAAOR,SAAP;AACD,CAbD;;AAeA,IAAIS,MAAJ;;AACO,MAAMC,iBAAiB,GAAG,MAAY;AAC3CD,EAAAA,MAAM,GAAGV,WAAW,EAApB;AACD,CAFM;;;AAIP,IAAIY,WAAW,GAAG,CAAlB;;AACO,MAAMC,aAAa,GAAIC,yBAAD,IAAqC;AAChEF,EAAAA,WAAW,IAAI,CAAf,CADgE,CAEhE;AACA;AACA;AACA;;AACA,MAAIA,WAAW,GAAG,EAAlB,EAAsB;AACpB,UAAMG,SAAS,GAAGL,MAAlB;AACA,UAAMT,SAAS,GAAGD,WAAW,EAA7B;AACAU,IAAAA,MAAM,GAAGT,SAAT;AACAc,IAAAA,SAAS,CAACC,GAAV;AACAJ,IAAAA,WAAW,GAAG,CAAd;AACD,GAND,MAMO;AACLF,IAAAA,MAAM,CAACO,iBAAP,CAAyBH,yBAAzB;AACD;AACF,CAfM;;;;AAiBA,MAAMI,aAAa,GAAG,CAAC;AAC5BC,EAAAA,IAD4B;AAE5BC,EAAAA,IAF4B;AAG5BC,EAAAA,KAH4B;AAI5BP,EAAAA,yBAJ4B;AAK5BQ,EAAAA;AAL4B,CAAD,KAO3B,IAAIC,OAAJ,CAAY,OAAOnB,OAAP,EAAgBoB,MAAhB,KAA2B;AACrC;AACA,MAAIC,OAAJ;;AACA,MAAI,CAACL,IAAL,EAAW;AACTK,IAAAA,OAAO,GAAG,oCAAeJ,KAAK,CAACK,QAAN,EAAf,EAAiCP,IAAjC,CAAV;AACD,GAFD,MAEO;AACLM,IAAAA,OAAO,GAAGL,IAAV;AACD;;AAED,MAAIO,gBAAgB,GAAG,KAAvB;;AACA,MAAIF,OAAO,CAACG,SAAZ,EAAuB;AACrBD,IAAAA,gBAAgB,GAAG,IAAnB;AACD,GAZoC,CAcrC;;;AACA,QAAM,8BAAwBF,OAAO,CAACN,IAAhC,CAAN;;AAEA,MAAI;AACF,UAAMU,UAAU,GAAG,MAAMnB,MAAM,CAACoB,UAAP,CAAkB;AACzCX,MAAAA,IADyC;AAEzCY,MAAAA,aAAa,EAAEN,OAAO,CAACO,SAFkB;AAGzClB,MAAAA,yBAHyC;AAIzCQ,MAAAA,SAJyC;AAKzCK,MAAAA;AALyC,KAAlB,CAAzB;AAOAvB,IAAAA,OAAO,CAACyB,UAAD,CAAP;AACD,GATD,CASE,OAAOI,KAAP,EAAc;AACdT,IAAAA,MAAM,CAACS,KAAD,CAAN;AACD;AACF,CA7BD,CAPK","sourcesContent":["import JestWorker from \"jest-worker\"\nimport _ from \"lodash\"\n\nimport { startListener } from \"../../bootstrap/requires-writer\"\nimport { findPageByPath } from \"../find-page-by-path\"\nimport { getPageData as getPageDataExperimental } from \"../get-page-data\"\n\nconst startWorker = (): any => {\n  const newWorker = new JestWorker(require.resolve(`./render-dev-html-child`), {\n    exposedMethods: [`renderHTML`, `deleteModuleCache`, `warmup`],\n    numWorkers: 1,\n    forkOptions: { silent: false },\n  })\n\n  // jest-worker is lazy with forking but we want to fork immediately so the user\n  // doesn't have to wait.\n  // @ts-ignore\n  newWorker.warmup()\n\n  return newWorker\n}\n\nlet worker\nexport const initDevWorkerPool = (): void => {\n  worker = startWorker()\n}\n\nlet changeCount = 0\nexport const restartWorker = (htmlComponentRendererPath): void => {\n  changeCount += 1\n  // Forking is expensive — each time we re-require the outputted webpack\n  // file, memory grows ~10 mb — 25 regenerations means ~250mb which seems\n  // like an accepatable amount of memory to grow before we reclaim it\n  // by rebooting the worker process.\n  if (changeCount > 25) {\n    const oldWorker = worker\n    const newWorker = startWorker()\n    worker = newWorker\n    oldWorker.end()\n    changeCount = 0\n  } else {\n    worker.deleteModuleCache(htmlComponentRendererPath)\n  }\n}\n\nexport const renderDevHTML = ({\n  path,\n  page,\n  store,\n  htmlComponentRendererPath,\n  directory,\n}): Promise<string> =>\n  new Promise(async (resolve, reject) => {\n    startListener()\n    let pageObj\n    if (!page) {\n      pageObj = findPageByPath(store.getState(), path)\n    } else {\n      pageObj = page\n    }\n\n    let isClientOnlyPage = false\n    if (pageObj.matchPath) {\n      isClientOnlyPage = true\n    }\n\n    // Ensure the query has been run and written out.\n    await getPageDataExperimental(pageObj.path)\n\n    try {\n      const htmlString = await worker.renderHTML({\n        path,\n        componentPath: pageObj.component,\n        htmlComponentRendererPath,\n        directory,\n        isClientOnlyPage,\n      })\n      resolve(htmlString)\n    } catch (error) {\n      reject(error)\n    }\n  })\n"],"file":"render-dev-html.js"}