"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.renderDevHTML = exports.restartWorker = exports.initDevWorkerPool = void 0;

var _jestWorker = _interopRequireDefault(require("jest-worker"));

var _requiresWriter = require("../../bootstrap/requires-writer");

var _findPageByPath = require("../find-page-by-path");

var _getPageData = require("../get-page-data");

const startWorker = () => {
  const newWorker = new _jestWorker.default(require.resolve(`./render-dev-html-child`), {
    exposedMethods: [`renderHTML`, `deleteModuleCache`, `warmup`],
    numWorkers: 1,
    forkOptions: {
      silent: false
    }
  }); // jest-worker is lazy with forking but we want to fork immediately so the user
  // doesn't have to wait.
  // @ts-ignore

  newWorker.warmup();
  return newWorker;
};

let worker;

const initDevWorkerPool = () => {
  worker = startWorker();
};

exports.initDevWorkerPool = initDevWorkerPool;
let changeCount = 0;

const restartWorker = htmlComponentRendererPath => {
  changeCount += 1; // Forking is expensive — each time we re-require the outputted webpack
  // file, memory grows ~10 mb — 25 regenerations means ~250mb which seems
  // like an accepatable amount of memory to grow before we reclaim it
  // by rebooting the worker process.

  if (changeCount > 25) {
    const oldWorker = worker;
    const newWorker = startWorker();
    worker = newWorker;
    oldWorker.end();
    changeCount = 0;
  } else {
    worker.deleteModuleCache(htmlComponentRendererPath);
  }
};

exports.restartWorker = restartWorker;

const renderDevHTML = ({
  path,
  page,
  store,
  htmlComponentRendererPath,
  directory
}) => new Promise(async (resolve, reject) => {
  (0, _requiresWriter.startListener)();
  let pageObj;

  if (!page) {
    pageObj = (0, _findPageByPath.findPageByPath)(store.getState(), path);
  } else {
    pageObj = page;
  }

  let isClientOnlyPage = false;

  if (pageObj.matchPath) {
    isClientOnlyPage = true;
  } // Ensure the query has been run and written out.


  await (0, _getPageData.getPageData)(pageObj.path);

  try {
    const htmlString = await worker.renderHTML({
      path,
      componentPath: pageObj.component,
      htmlComponentRendererPath,
      directory,
      isClientOnlyPage
    });
    resolve(htmlString);
  } catch (error) {
    reject(error);
  }
});

exports.renderDevHTML = renderDevHTML;
//# sourceMappingURL=render-dev-html.js.map